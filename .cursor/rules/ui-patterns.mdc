---
description: 
globs: 
---
# UI Development Guidelines

## Overview
For related guidelines:
- State Management: See `state-management.mdc`
- Error Handling: See `error-handling.mdc`
- Analytics: See `analytics.mdc`
- TDD Process: See `tdd-workflow.mdc`

## Widget Structure

### Base Widget Pattern
```dart
class FeatureScreen extends StatelessWidget {
  const FeatureScreen({super.key});

  @override
  Widget build(BuildContext context) {
    return BlocProvider(
      create: (context) => getIt<FeatureCubit>()..initialize(),
      child: const FeatureView(),
    );
  }
}

class FeatureView extends StatelessWidget {
  const FeatureView({super.key});

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: const FeatureAppBar(),
      body: BlocBuilder<FeatureCubit, FeatureState>(
        builder: (context, state) {
          return state.data.when(
            initial: () => const InitialContent(),
            inProgress: () => const LoadingIndicator(),
            failure: (error) => ErrorView(
              error: error,
              onRetry: () => context.read<FeatureCubit>().retry(),
            ),
            success: (data) => SuccessContent(data: data),
          );
        },
      ),
    );
  }
}
```

## State Representation

### Loading States
```dart
class LoadingIndicator extends StatelessWidget {
  const LoadingIndicator({super.key});

  @override
  Widget build(BuildContext context) {
    return const Center(
      child: CircularProgressIndicator.adaptive(),
    );
  }
}
```

### Error States
```dart
class ErrorView extends StatelessWidget {
  final Object error;
  final VoidCallback onRetry;

  const ErrorView({
    required this.error,
    required this.onRetry,
    super.key,
  });

  @override
  Widget build(BuildContext context) {
    return Center(
      child: Column(
        mainAxisAlignment: MainAxisAlignment.center,
        children: [
          Text(error.toUserFriendlyMessage()),
          const SizedBox(height: 16),
          ElevatedButton.icon(
            onPressed: onRetry,
            icon: const Icon(Icons.refresh),
            label: const Text('Retry'),
          ),
        ],
      ),
    );
  }
}
```

### Empty States
```dart
class EmptyContent extends StatelessWidget {
  final String message;
  final VoidCallback? onAction;

  const EmptyContent({
    required this.message,
    this.onAction,
    super.key,
  });

  @override
  Widget build(BuildContext context) {
    return Center(
      child: Column(
        mainAxisAlignment: MainAxisAlignment.center,
        children: [
          Text(message),
          if (onAction != null) ...[
            const SizedBox(height: 16),
            ElevatedButton(
              onPressed: onAction,
              child: const Text('Take Action'),
            ),
          ],
        ],
      ),
    );
  }
}
```

## Responsive Design

### Screen Breakpoints
```dart
class Breakpoints {
  static const double mobile = 600;
  static const double tablet = 900;
  static const double desktop = 1200;
}

class ResponsiveBuilder extends StatelessWidget {
  final Widget Function(BuildContext, ScreenType) builder;

  const ResponsiveBuilder({required this.builder, super.key});

  @override
  Widget build(BuildContext context) {
    return LayoutBuilder(
      builder: (context, constraints) {
        final width = constraints.maxWidth;
        final screenType = switch (width) {
          <= Breakpoints.mobile => ScreenType.mobile,
          <= Breakpoints.tablet => ScreenType.tablet,
          _ => ScreenType.desktop,
        };
        return builder(context, screenType);
      },
    );
  }
}
```

## Theme Implementation

### Theme Extension
```dart
class CustomThemeExtension extends ThemeExtension<CustomThemeExtension> {
  final Color primaryTextColor;
  final Color secondaryTextColor;
  final double borderRadius;

  const CustomThemeExtension({
    required this.primaryTextColor,
    required this.secondaryTextColor,
    required this.borderRadius,
  });

  @override
  ThemeExtension<CustomThemeExtension> copyWith({
    Color? primaryTextColor,
    Color? secondaryTextColor,
    double? borderRadius,
  }) {
    return CustomThemeExtension(
      primaryTextColor: primaryTextColor ?? this.primaryTextColor,
      secondaryTextColor: secondaryTextColor ?? this.secondaryTextColor,
      borderRadius: borderRadius ?? this.borderRadius,
    );
  }

  @override
  ThemeExtension<CustomThemeExtension> lerp(
    ThemeExtension<CustomThemeExtension>? other,
    double t,
  ) {
    if (other is! CustomThemeExtension) return this;

    return CustomThemeExtension(
      primaryTextColor: Color.lerp(primaryTextColor, other.primaryTextColor, t)!,
      secondaryTextColor: Color.lerp(secondaryTextColor, other.secondaryTextColor, t)!,
      borderRadius: lerpDouble(borderRadius, other.borderRadius, t)!,
    );
  }
}
```

## Best Practices

### Widget Organization
- Separate container from presentation
- Use composition over inheritance
- Keep widgets focused and small
- Extract reusable widgets
- Use const constructors
- Implement proper cleanup

### Performance
- Use const widgets
- Implement RepaintBoundary
- Lazy load when possible
- Cache expensive computations
- Optimize image loading
- Minimize rebuilds

### Accessibility
- Provide meaningful labels
- Support screen readers
- Handle text scaling
- Implement keyboard navigation
- Support RTL layouts
- Maintain proper contrast

### Error Handling
- Show user-friendly messages
- Provide recovery actions
- Maintain context
- Handle edge cases
- Support offline states
- Implement retry mechanisms

### Animation
- Use implicit animations
- Keep animations smooth
- Support reduced motion
- Handle interruptions
- Maintain 60fps
- Use hero transitions

### Forms
- Validate input
- Show error messages
- Handle keyboard
- Support autofill
- Implement focus management
- Save form state

### Lists
- Implement pagination
- Handle empty states
- Show loading states
- Support pull-to-refresh
- Cache list items
- Handle item updates

### Navigation
- Deep linking support
- Handle back navigation
- Preserve state
- Animate transitions
- Support gestures
- Handle errors

## Testing UI

### Widget Testing
```dart
testWidgets('shows error view on failure', (tester) async {
  await tester.pumpWidget(
    BlocProvider.value(
      value: cubit,
      child: const FeatureView(),
    ),
  );

  expect(find.byType(LoadingIndicator), findsOneWidget);
  
  await tester.tap(find.byType(RetryButton));
  await tester.pumpAndSettle();
  
  expect(find.byType(ErrorView), findsOneWidget);
});
```

### Golden Testing
```dart
goldenTest(
  'feature screen matches golden file',
  builder: () => const FeatureScreen(),
  fileName: 'feature_screen.png',
);
```

## UI Test-Driven Development

### Step 1: Write Widget Test First
```dart
// test/presentation/widgets/weather_card_test.dart

void main() {
  group('WeatherCard', () {
    testWidgets('displays weather information correctly', (tester) async {
      const weather = WeatherInfo(
        temperature: 20,
        condition: 'Sunny',
        location: 'London',
      );

      await tester.pumpWidget(
        const MaterialApp(
          home: WeatherCard(weather: weather),
        ),
      );

      expect(find.text('20°C'), findsOneWidget);
      expect(find.text('Sunny'), findsOneWidget);
      expect(find.text('London'), findsOneWidget);
    });

    testWidgets('shows placeholder when image fails to load', (tester) async {
      const weather = WeatherInfo(
        temperature: 20,
        condition: 'Sunny',
        location: 'London',
        iconUrl: 'invalid_url',
      );

      await tester.pumpWidget(
        const MaterialApp(
          home: WeatherCard(weather: weather),
        ),
      );

      expect(find.byType(PlaceholderIcon), findsOneWidget);
    });

    testWidgets('calls onTap when card is tapped', (tester) async {
      var tapped = false;
      
      await tester.pumpWidget(
        MaterialApp(
          home: WeatherCard(
            weather: weather,
            onTap: () => tapped = true,
          ),
        ),
      );

      await tester.tap(find.byType(WeatherCard));
      await tester.pumpAndSettle();

      expect(tapped, isTrue);
    });
  });
}
```

### Step 2: Run Tests (Should Fail)
```bash
flutter test test/presentation/widgets/weather_card_test.dart
```

Expected Output:
```
00:01 +0 -1: WeatherCard displays weather information correctly [E]
  Widget not found: Text("20°C")
  
00:02 +0 -2: WeatherCard shows placeholder when image fails to load [E]
  Widget type PlaceholderIcon not found
```

### Step 3: Implement Widget
```dart
// lib/presentation/widgets/weather_card.dart

class WeatherCard extends StatelessWidget {
  final WeatherInfo weather;
  final VoidCallback? onTap;

  const WeatherCard({
    required this.weather,
    this.onTap,
    super.key,
  });

  @override
  Widget build(BuildContext context) {
    return Card(
      child: InkWell(
        onTap: onTap,
        child: Padding(
          padding: const EdgeInsets.all(16),
          child: Column(
            children: [
              Text(
                '${weather.temperature}°C',
                style: Theme.of(context).textTheme.headlineMedium,
              ),
              const SizedBox(height: 8),
              if (weather.iconUrl != null)
                Image.network(
                  weather.iconUrl!,
                  errorBuilder: (_, __, ___) => const PlaceholderIcon(),
                ),
              const SizedBox(height: 8),
              Text(weather.condition),
              Text(weather.location),
            ],
          ),
        ),
      ),
    );
  }
}
```

### Step 4: Run Tests Again (Should Pass)
```bash
flutter test test/presentation/widgets/weather_card_test.dart
```

Expected Output:
```
00:02 +3 -0: All tests passed!
```

### Step 5: Add Golden Tests
```dart
void main() {
  group('WeatherCard Golden Tests', () {
    goldenTest(
      'matches golden image',
      builder: () => const MaterialApp(
        home: Scaffold(
          body: Center(
            child: WeatherCard(weather: weather),
          ),
        ),
      ),
      fileName: 'weather_card.png',
    );

    goldenTest(
      'matches golden image in dark theme',
      builder: () => MaterialApp(
        theme: ThemeData.dark(),
        home: const Scaffold(
          body: Center(
            child: WeatherCard(weather: weather),
          ),
        ),
      ),
      fileName: 'weather_card_dark.png',
    );
  });
}
```

## UI TDD Best Practices

### Test Organization
- Group related widget tests
- Test different states/variations
- Test user interactions
- Test error cases
- Test accessibility

### Widget Test Structure
1. Arrange: Setup widget with test data
2. Act: Interact with widget
3. Assert: Verify UI elements
4. Cleanup: Reset state if needed

### What to Test
- Visual elements present
- Layout structure correct
- User interactions work
- Error states handled
- Accessibility features
- Theme variations
- Screen size adaptations

### Golden Test Guidelines
- Test different themes
- Test different locales
- Test different screen sizes
- Test different states
- Document test scenarios
- Update with caution

### Common Test Patterns

#### Layout Tests
```dart
testWidgets('maintains layout on small screen', (tester) async {
  tester.binding.window.physicalSizeTestValue = const Size(320, 480);
  
  await tester.pumpWidget(const MyWidget());
  
  expect(find.byType(Overflow), findsNothing);
});
```

#### Interaction Tests
```dart
testWidgets('updates UI on user interaction', (tester) async {
  await tester.pumpWidget(const MyWidget());
  
  await tester.tap(find.byType(Button));
  await tester.pumpAndSettle();
  
  expect(find.text('Updated'), findsOneWidget);
});
```

#### Theme Tests
```dart
testWidgets('applies theme correctly', (tester) async {
  await tester.pumpWidget(
    MaterialApp(
      theme: ThemeData.light(),
      home: const MyWidget(),
    ),
  );
  
  final text = tester.widget<Text>(find.byType(Text));
  expect(text.style?.color, equals(Colors.black));
});
``` 
