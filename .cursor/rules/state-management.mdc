---
description: 
globs: 
---
# State Management Guidelines

## Overview
For detailed guidelines on specific aspects, refer to:
- Testing: See `testing.mdc` and `tdd-workflow.mdc`
- Error Handling: See `error-handling.mdc`
- Analytics: See `analytics.mdc`
- Dependencies: See `dependencies.mdc`

## Test-Driven Development Workflow

### Step 1: Write the Test First
```dart
void main() {
  group('WeatherCubit', () {
    late MockWeatherRepository repository;
    late MockLocationService locationService;
    late MockAnalytics analytics;
    late WeatherCubit cubit;

    setUp(() {
      repository = MockWeatherRepository();
      locationService = MockLocationService();
      analytics = MockAnalytics();
      cubit = WeatherCubit(
        repository: repository,
        locationService: locationService,
        analytics: analytics,
      );
    });

    test('initial state should be correct', () {
      expect(cubit.state, WeatherState.initial());
      verify(analytics.logInitialized()).called(1);
    });

    blocTest<WeatherCubit, WeatherState>(
      'should emit success state when weather data is loaded',
      build: () {
        when(locationService.checkPermission())
            .thenAnswer((_) async => const DataState.success(data: null));
        when(repository.getWeatherInfo())
            .thenAnswer((_) async => DataState.success(data: weatherInfo));
        return cubit;
      },
      act: (cubit) => cubit.initialize(),
      expect: () => [
        state.copyWith(locationPermission: const DataState.inProgress()),
        state.copyWith(
          locationPermission: const DataState.success(data: null),
          weatherInfo: const DataState.inProgress(),
        ),
        state.copyWith(
          locationPermission: const DataState.success(data: null),
          weatherInfo: DataState.success(data: weatherInfo),
        ),
      ],
    );
  });
}
```

### Step 2: Run the Test (Should Fail)
- Run test using `flutter test`
- Verify test fails for expected reasons
- Review error messages

### Step 3: Implement the Feature
```dart
class WeatherCubit extends Cubit<WeatherState> {
  // Implementation to make tests pass
}
```

### Step 4: Run Tests Again (Should Pass)
- Run tests to verify implementation
- All tests should pass
- No regression in existing tests

### Step 5: Refactor if Needed
- Clean up implementation
- Maintain test coverage
- Improve code quality
- Tests should still pass

## Development Rules
1. Never write production code without a failing test
2. Write minimal test code to cause failure
3. Write minimal production code to pass test
4. Refactor while keeping tests green

## Test Categories for State Management

### Unit Tests
- State transitions
- Computed properties
- Error handling
- Event handling

### Integration Tests
- Repository integration
- Service interactions
- Analytics tracking
- Cache management

### Widget Tests
- UI state representation
- User interactions
- Error displays
- Loading states

## Core State Types

### DataState Pattern
```dart
@freezed
class DataState<T> with _$DataState<T> {
  const factory DataState.initial() = _Initial<T>;
  const factory DataState.inProgress() = _InProgress<T>;
  const factory DataState.failure(Object error) = _Failure<T>;
  const factory DataState.success({
    required T data,
  }) = _Success<T>;
}
```

### Feature State Pattern
```dart
@freezed
class WeatherState with _$WeatherState {
  const factory WeatherState({
    required DataState<WeatherInfo> weatherInfo,
    required DataState<List<ForecastDay>> forecast,
    DataState<void>? locationPermission,
  }) = _WeatherState;

  factory WeatherState.initial() => const WeatherState(
    weatherInfo: DataState.initial(),
    forecast: DataState.initial(),
  );
}
```

## Cubit Implementation

### Base Structure
```dart
class WeatherCubit extends Cubit<WeatherState> {
  final IWeatherRepository _repository;
  final ILocationService _locationService;
  final IAnalytics _analytics;

  WeatherCubit({
    required IWeatherRepository repository,
    required ILocationService locationService,
    required IAnalytics analytics,
  }) : _repository = repository,
       _locationService = locationService,
       _analytics = analytics,
       super(WeatherState.initial());

  Future<void> initialize() async {
    _analytics.logInitialized();
    await _checkLocationPermission();
    if (state.locationPermission?.isSuccess ?? false) {
      await _loadWeatherData();
    }
  }

  @override
  Future<void> close() {
    _analytics.logDisposed();
    return super.close();
  }
}
```

## State Management Best Practices

### State Design
- Keep state immutable using Freezed
- Use DataState for all async operations
- Implement computed properties
- Avoid redundant state
- Keep state normalized
- Use sealed classes for union types

### Cubit Guidelines
- Single responsibility per Cubit
- Handle initialization in initialize()
- Clean up resources in close()
- Track analytics events (see `analytics.mdc` for details)
- Handle errors gracefully (see `error-handling.mdc` for patterns)
- Prevent concurrent operations
- Implement proper error recovery

### State Updates
- Emit state atomically
- Validate state changes
- Handle edge cases
- Use proper error handling
- Implement optimistic updates
- Handle race conditions
- Cache management

## Performance Considerations
- Minimize rebuilds
- Use equatable
- Implement proper disposal
- Memory management
- State restoration
- Handle background updates

## Error Handling
- Use DataState for error states
- Implement retry mechanisms
- Track error analytics
- Provide recovery options
- Log error context
- Handle edge cases

## State Persistence
- Implement hydration
- Handle migration
- Cache invalidation
- Offline support
- State restoration
- Error recovery

## Dependency Management
- Use dependency injection
- Register dependencies early
- Clean up resources
- Handle lifecycle events
- Manage subscriptions

## Analytics Integration
- Track state transitions
- Log error states
- Monitor performance
- Track user actions
- Measure success rates
- Monitor state changes 
