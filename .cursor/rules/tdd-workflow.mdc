---
description: 
globs: 
---
# Test-Driven Development Workflow

## Directory Structure
```
test/
└── feature/              # e.g. weather/
    ├── domain/
    │   └── test/
    │       ├── models/   # For domain model tests
    │       └── services/ # For service interface tests
    ├── application/
    │   └── test/
    │       ├── state/    # For state tests
    │       └── cubits/   # For cubit tests
    ├── infrastructure/
    │   └── test/
    │       ├── services/ # For service implementation tests
    │       └── mappers/  # For DTO mapper tests
    └── presentation/
        └── test/
            ├── widgets/  # For feature-specific widget tests
            └── screens/  # For screen tests
```

## Development Cycle

### 1. Write Test First
```dart
// test/application/cubits/weather_cubit_test.dart

import 'package:flutter_test/flutter_test.dart';
import 'package:bloc_test/bloc_test.dart';
import 'package:mockito/mockito.dart';

void main() {
  group('WeatherCubit', () {
    late MockWeatherRepository repository;
    late MockLocationService locationService;
    late MockAnalytics analytics;
    late WeatherCubit cubit;

    setUp(() {
      repository = MockWeatherRepository();
      locationService = MockLocationService();
      analytics = MockAnalytics();
      cubit = WeatherCubit(
        repository: repository,
        locationService: locationService,
        analytics: analytics,
      );
    });

    tearDown(() {
      cubit.close();
    });

    test('initial state should be correct', () {
      expect(cubit.state, WeatherState.initial());
      verify(analytics.logInitialized()).called(1);
    });

    blocTest<WeatherCubit, WeatherState>(
      'should emit failure when location permission is denied',
      build: () {
        when(locationService.checkPermission())
            .thenAnswer((_) async => DataState.failure(
                  const PermissionError('Location permission denied'),
                ));
        return cubit;
      },
      act: (cubit) => cubit.initialize(),
      expect: () => [
        state.copyWith(locationPermission: const DataState.inProgress()),
        state.copyWith(
          locationPermission: DataState.failure(
            const PermissionError('Location permission denied'),
          ),
        ),
      ],
      verify: (_) {
        verify(analytics.logFailure(any)).called(1);
        verifyNever(repository.getWeatherInfo());
      },
    );
  });
}
```

### 2. Run Tests (Should Fail)
```bash
# Run specific test
flutter test test/application/cubits/weather_cubit_test.dart

# Run all tests
flutter test
```

Expected Output:
```
00:02 +0 -1: WeatherCubit initial state should be correct [E]
  NoSuchMethodError: The method 'logInitialized' was called on null.
  
00:03 +0 -2: WeatherCubit should emit failure when location permission is denied [E]
  NoSuchMethodError: The method 'checkPermission' was called on null.
```

### 3. Implement Feature
```dart
// lib/application/cubits/weather_cubit.dart

class WeatherCubit extends Cubit<WeatherState> {
  final IWeatherRepository _repository;
  final ILocationService _locationService;
  final IAnalytics _analytics;

  WeatherCubit({
    required IWeatherRepository repository,
    required ILocationService locationService,
    required IAnalytics analytics,
  }) : _repository = repository,
       _locationService = locationService,
       _analytics = analytics,
       super(WeatherState.initial()) {
    _analytics.logInitialized();
  }

  Future<void> initialize() async {
    emit(state.copyWith(
      locationPermission: const DataState.inProgress(),
    ));

    final permissionResult = await _locationService.checkPermission();
    
    emit(state.copyWith(locationPermission: permissionResult));

    if (permissionResult.hasFailure) {
      _analytics.logFailure(permissionResult.failure);
      return;
    }

    await _loadWeatherData();
  }
}
```

### 4. Run Tests Again (Should Pass)
```bash
flutter test test/application/cubits/weather_cubit_test.dart
```

Expected Output:
```
00:02 +2 -0: All tests passed!
```

### 5. Refactor If Needed
- Improve code organization
- Extract common test setup
- Add test helpers
- Improve naming
- Add documentation

## TDD Rules

### Always Write Test First
- Write minimal failing test
- Test should clearly specify behavior
- Include error cases
- Test edge cases

### Keep Tests Focused
- One behavior per test
- Clear test names
- Use setup/teardown
- Group related tests

### Test Structure
- Arrange (Setup)
- Act (Execute)
- Assert (Verify)
- Cleanup (Teardown)

### Mocking Guidelines
- Mock external dependencies
- Use strict mocks
- Verify interactions
- Mock minimum required

### Test Coverage
- 100% coverage for business logic
- Test all state transitions
- Test error scenarios
- Test edge cases

## Common Test Patterns

### State Tests
```dart
blocTest<FeatureCubit, FeatureState>(
  'description of the test case',
  build: () => cubit,
  act: (cubit) => cubit.someMethod(),
  expect: () => [
    state.copyWith(status: const DataState.inProgress()),
    state.copyWith(status: const DataState.success(data: expectedData)),
  ],
);
```

### Error Tests
```dart
blocTest<FeatureCubit, FeatureState>(
  'should handle errors properly',
  build: () {
    when(dependency.someMethod())
        .thenThrow(const CustomError('error message'));
    return cubit;
  },
  act: (cubit) => cubit.someMethod(),
  expect: () => [
    state.copyWith(status: const DataState.inProgress()),
    state.copyWith(status: DataState.failure(const CustomError('error message'))),
  ],
  verify: (_) => verify(analytics.logError(any)).called(1),
);
```

### Widget Tests
```dart
testWidgets('widget test description', (tester) async {
  await tester.pumpWidget(
    BlocProvider.value(
      value: cubit,
      child: const TestedWidget(),
    ),
  );

  expect(find.byType(LoadingIndicator), findsOneWidget);
  
  await tester.tap(find.byType(RetryButton));
  await tester.pumpAndSettle();
  
  expect(find.byType(SuccessView), findsOneWidget);
});
``` 